# Linux的分段管理

## GDT的16个表项

![1532224599644.png](image/1532224599644.png)

* 0x7f = 0~127 = 128B，每个表项8字节，128/8 = 16个表项


![1532224606614.png](image/1532224606614.png)

![1532224730779.png](image/1532224730779.png)

![1532224749640.png](image/1532224749640.png)

![1532224759615.png](image/1532224759615.png)

![1532224767378.png](image/1532224767378.png)

* GDT第0项永远不得使用，LDT第0项理论可以使用，但是一般不使用。

![1532224812933.png](image/1532224812933.png)

![1532224862435.png](image/1532224862435.png)

![1532224874434.png](image/1532224874434.png)

![1532224886548.png](image/1532224886548.png)

![1532224892089.png](image/1532224892089.png)

![1532224910882.png](image/1532224910882.png)

![1532224936383.png](image/1532224936383.png)

![1532224947833.png](image/1532224947833.png)

![1532224959029.png](image/1532224959029.png)

![1532224987820.png](image/1532224987820.png)

![1532224996856.png](image/1532224996856.png)

![1532225009604.png](image/1532225009604.png)


## 如何设置GDT表项

![1532225042415.png](image/1532225042415.png)

![1532225112191.png](image/1532225112191.png)

![1532225168354.png](image/1532225168354.png)

![1532225197861.png](image/1532225197861.png)

![1532225398820.png](image/1532225398820.png)

![1532225554687.png](image/1532225554687.png)

* 多处理器系统，每个CPU都有自己的GDT表，每个GDT表都存放在 per cpu变量gdt_page中

![1532225609849.png](image/1532225609849.png)

![1532225622369.png](image/1532225622369.png)

* 描述符结构体

![1532225644862.png](image/1532225644862.png)

## per cpu变量

![1532225659641.png](image/1532225659641.png)

* 都是拷贝过去的，放在平坦模式固定位置。
* 对于f而言，生成的代码、x的地址都是固定的

![1532226008100.png](image/1532226008100.png)

* FS：标志段寄存器
* GS：全局段寄存器
* 虽然偏移一样，但是基址不一样，访问的就不一样了

![1532226172774.png](image/1532226172774.png)

* MSR-Model Specific Registers (特殊模块寄存器)

![1532226333330.png](image/1532226333330.png)

![1532226471248.png](image/1532226471248.png)

* 虽然标记64位，但是32位也是一样的。因为它是64bit寄存器，别理解错了

![1532227073211.png](image/1532227073211.png)

![1532227094907.png](image/1532227094907.png)

![1532227119763.png](image/1532227119763.png)

* percpu编写主要是在多个CPU的运行环境中，每个处理器之间并没有交互的内容，他们有共同的处理方法，但是，他们的数据并不需要共享和交互，为了保持每个CPU都独立处理自己的任务，而不给其他CPU带来干扰。对于共同结构的数据，我们可以进行percpu编程处理，从而避免多个CPU对数据进行处理时，需要加锁。
* 多个CPU之间共享内存的情况。这种情况下，任何一个CPU如果修改了共享内存就会导致所有其他CPU的L1 cache上对应的cache line变成invalid（硬件完成）。虽然对性能造成影响，但是系统必须这么做，因为需要维持cache的同步。将一个共享memory变成Per-CPU memory本质上是一个耗费更多memory来解决performance的方法。当一个在多个CPU之间共享的变量变成每个CPU都有属于自己的一个私有的变量的时候，我们就不必考虑来自多个CPU上的并发，仅仅考虑本CPU上的并发就OK了。当然，还有一点要注意，那就是在访问Per-CPU变量的时候，不能调度，当然更准确的说法是该task不能调度到其他CPU上去。目前的内核的做法是在访问Per-CPU变量的时候disable preemptive，虽然没有能够完全避免使用锁的机制（disable preemptive也是一种锁的机制），但毫无疑问，这是一种代价比较小的锁。

![1532232516321.png](image/1532232516321.png)

![1532232528958.png](image/1532232528958.png)



## msr寄存器

![1532229774731.png](image/1532229774731.png)

![1532229797992.png](image/1532229797992.png)



* 一类头疼的寄存器

* MSR 是CPU 的一组64 位寄存器，可以分别通过RDMSR 和WRMSR 两条指令进行读和写的操作，前提要在ECX 中写入MSR 的地址。对于RDMSR 指令，将会返回相应的MSR 中64bit 信息到(EDX：EAX)寄存器中；对于WRMSR 指令，把要写入的信息存入(EDX：EAX)中，执行写指令后，即可将相应的信息存入ECX 指定的MSR 中。MSR 的指令必须执行在level 0 或实模式下。

* 作用
  - MSR 总体来是为了设置CPU 的工作环境和标示CPU 的工作状态，包括温度控制，性能监控等

![1532226966848.png](image/1532226966848.png)

![1532227340155.png](image/1532227340155.png)

![1532227388713.png](image/1532227388713.png)

![1532227411144.png](image/1532227411144.png)

![1532229698887.png](image/1532229698887.png)



* 只有Per-CPU变量的原始变量还是不够的，必须为每一个CPU建立一个副本，怎么建？直接静态定义一个NR_CPUS的数组？NR_CPUS定义了系统支持的最大的processor的个数，并不是实际中系统processor的数目，这样的定义非常浪费内存。此外，静态定义的数据在内存中连续，对于UMA系统而言是OK的，对于NUMA系统，每个CPU上的Per-CPU变量的副本应该位于它访问最快的那段memory上，也就是说Per-CPU变量的各个CPU副本可能是散布在整个内存地址空间的，而这些空间之间是有空洞的。本质上，副本per cpu内存的分配归属于内存管理子系统

![1532227551965.png](image/1532227551965.png)

![1532229616883.png](image/1532229616883.png)



## 总结

* 常见各种段，cs,ds都是段选子，指向GDT、LDT中某项。但是fs、gs特殊，它的基址存放在MSR类寄存器中。而不是8B描述符中。
* Per CPU不是硬件特性，是软件利用硬件的特性。线性地址=段基址+偏移地址。per cpu就是利用了段基址不同，但是偏移地址一样来实现不同CPU访问不同变量。
* fs,gs的段基址不是放在8B中，而是放在MSR类寄存器中。这个MSR类寄存器基地址很特殊的固定在线性地址某个地方。MSR类寄存器保存了fs和gs基地址，但是每个CPU msr类寄存器又都不一样

![1532228089970.png](image/1532228089970.png)

![1532228149958.png](image/1532228149958.png)

* 那么不同CPU读该线性地址，就是读到不同fs、gs基地址

![1532228183135.png](image/1532228183135.png)

![1532228576178.png](image/1532228576178.png)

* 两种方法效果一样，宏实现本质也是第一种
* 基址存放的地址和基址是不一样的哦

## 参考博客

<https://blog.csdn.net/longwang155069/article/details/52033243>





## END
